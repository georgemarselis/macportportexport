#!/opt/local/bin/perl -wT


# macportportexport: reconstruct a macport command line, so you can reuse
#	your programs.
# 		Also, produces puppet templates, chef recepies and ansible solutions

# Copyright 2014 George Marselis <george@marsel.is>

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Data::Dumper;
use File::Copy;
use POSIX qw(strftime);
use Getopt::Long;
use Sys::Hostname;

my $macports_bin = '/opt/local/bin/port';	 # should come up with a way to decide
my $homebrew_bin = '/usr/local/bin/brew'; 	 # which to use by default;
my $nix_bin 	 = '/opt/local/bin/nix-env';

# Set PATH and remove some environment variables for running in taint mode.
$ENV{ 'PATH' } = '';
delete @ENV{ 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };

sub get_portpackagesandvariants
{

	my $action = 'installed';
	my $type    = 'active';
	my @args 	= ( $action, $type );

	open( my $porthandle, '-|', $macports_bin, @args ) or
		die "Cannot run $macports_bin: $!";

	return parse_macports( <$porthandle> );

}


sub parse_macports
{

	my @list 		 = @_;
	my %portshash 	 = ( );
	my $variants 	 = '';
	my $program_name = '';
	
	foreach( @list ) {

		/The following/ and next;

		my $tempbuffer = $_; 	# read in, clean up.
		chomp $tempbuffer;
		$tempbuffer =~ s/^\s*//;
		$tempbuffer =~ s/ \(active\)//;

		( $program_name , $variants ) = split ' ', $tempbuffer;
		
		$portshash{ $program_name } = $variants;
	}

	return %portshash;
}


###########
# dump the list of packages and variants as modules, ready to 
# 	puppet apply them
#
sub puppet_template
{
	my $root_dir		= 'puppet';

	my %portshash 		 = get_portpackagesandvariants( );
	my @listofpackages 	 = keys %portshash;

	create_root_directory(    $root_dir  );
	write_root_manifest( 	  $root_dir  );
	create_module_hierarchy(  $root_dir, @listofpackages );
	write_module_manistests(  $root_dir, %portshash );
	write_defaults_manifests( $root_dir, @listofpackages );
	write_macports_manifest(  $root_dir  );
	
	print "\nYour puppet files are ready. Please type\n\tsudo puppet apply --verbose ./$root_dir/manifests/site.pp --modulepath=puppet/modules\n\n".
			" to apply your puppet manifestos.\n";

}


sub create_root_directory
{
	my $root_dir = $_[0];

	if( ! -d $root_dir ) {
		mkdir $root_dir or
			die $0." cannot create root puppet dir $root_dir: $!";
	}
}


sub write_root_manifest 
{ 

	my $root_dir 			= $_[0];
	my $root_manifest_dir 	= $root_dir.'/manifests';
	my $sites_pp_file 		= $root_manifest_dir.'/site.pp';
	my $root_nodes_dir 		= $root_manifest_dir.'/nodes';
	my $example_node_file 	= $root_nodes_dir.'/wintermute.lan.pp';
	my $writebuffer 		= '';

	mkdir $root_manifest_dir or die "Could not create $root_manifest_dir: $!";
	mkdir $root_nodes_dir    or die "Could not create $root_nodes_dir";

	my $datestring = strftime "%Y-%m-%d_%T", localtime;
	$writebuffer = "########################################################################
#
# Autogenerated by $0 on $datestring
#

import \"nodes/*.pp\"

";

	open my $filehandle, '>', $sites_pp_file;
	printf $filehandle $writebuffer;
	close $filehandle;

	# example
	my $host = hostname;
	my $node_buffer =  "########################################################################
#
# Autogenerated by $0 on $datestring
#

node '$host' {

	include defaults
}

";

	open $filehandle, '>', $example_node_file;
	printf $filehandle $node_buffer;
	close $filehandle;
}


sub create_module_hierarchy 
{
	my ( $root_dir, @listofpackages ) 	= @_;
	my $modules_dir 					= $root_dir.'/modules';
	
	( ! -d $modules_dir ) and mkdir $modules_dir 	or die "$0: could not make $modules_dir: $!";

	# add defaults module
	push @listofpackages, 'defaults';
	@listofpackages = sort @listofpackages; # neatness sake

	foreach my $module ( @listofpackages ) {
	
		$module =~ s/\./-/g;
		$module = lc $module;
		my $puppetmodule_dir 		= $modules_dir.'/'.$module;
		my $puppetmanifest_dir 		= $puppetmodule_dir.'/manifests';
	
		if( ! -d $puppetmodule_dir ) {
			mkdir $puppetmodule_dir or 
				die "$0: could not create directory $puppetmodule_dir : $!";
		}

		if( ! -d $puppetmanifest_dir ) {
			mkdir $puppetmanifest_dir or 
				die "$0: could not create directory $puppetmanifest_dir : $!";
		}
	}
}


sub write_module_manistests
{
	my ( $root_dir, %portshash ) 	= @_;
	my $modules_dir 			 	= $root_dir.'/modules';
	my @listofpackages 				= keys %portshash;

	foreach my $package ( @listofpackages ) {
		
		my $package_name = $package;
		$package =~ s/\./-/g;
		$package = lc $package;
		
		my $puppet_module_dir 			= $modules_dir.'/'.$package;
		my $puppet_module_manifest_dir 	= $puppet_module_dir.'/manifests';
		my $puppet_module_manifest_file = $puppet_module_manifest_dir.'/init.pp';

		( ! -d $puppet_module_manifest_dir ) and die ": $puppet_module_manifest_dir does not exist";
		open my $filehandle, '>', $puppet_module_manifest_file or die ": could not open $puppet_module_manifest_file : $!";

		my $writebuffer  = "
class $package {

	package { '$package':
		name 		=> '$package_name',
		provider 	=> 'macports',
 		ensure 		=> '$portshash{ $package_name }',
	}
}
";
		printf $filehandle $writebuffer or die "$0: cannot print to file $puppet_module_manifest_file : $!";
		close $filehandle;
	}
}


sub write_defaults_manifests {

	my ( $root_dir, @listofpackages ) 	= @_;
	my $modules_dir 					= $root_dir.'/modules';
	my $defaults_module_dir 			= $modules_dir.'/defaults';
	my $defaults_modules_manifests_dir 	= $defaults_module_dir.'/manifests';
	my $defaults_modules_manifests_file = $defaults_modules_manifests_dir.'/init.pp';
	my $writebuffer 					= '';

	( ! -d $defaults_modules_manifests_dir ) and
		die ": $defaults_modules_manifests_dir was not created during initialization";

	my $datestring = strftime "%Y-%m-%d_%T", localtime;
	$writebuffer = "########################################################################
#
# Autogenerated by $0 on $datestring
#

class defaults {

";
	my @unsortedarray = ( );
	foreach my $pkg ( @listofpackages ) {
		push @unsortedarray, lc $pkg;

	}
	@listofpackages = sort @unsortedarray;
	
	foreach my $package ( @listofpackages )	{
		$package =~ s/\./-/g;
		$package = lc $package;
		$writebuffer .= sprintf( "\tinclude '$package'\n" );
	}
	$writebuffer .= sprintf( "}\n" );

	open my $filehandle, '>', $defaults_modules_manifests_file;
	printf $filehandle $writebuffer;

	close $filehandle;

}


sub write_macports_manifest 
{

	my $root 						= $_[0];
	my $modules_dir 				= $root.'/modules';
	my $macports_module 			= $modules_dir.'/macports';
	my $macports_module_manifestdir = $macports_module.'/manifests';
	my $macports_manifest 			= $macports_module_manifestdir.'/init.pp';
	my $macports_module_filesdir	= $macports_module.'/files';
	my $writebuffer 				= '';


	( ! -d $macports_module 			) and mkdir $macports_module; 
	( ! -d $macports_module_manifestdir ) and mkdir $macports_module_manifestdir;
	( ! -d $macports_module_filesdir 	) and mkdir $macports_module_filesdir;



	$writebuffer  = "
class macports {


	\$osnickname = \$macosx_productversion_major ? {
		'10.5' => 'Leopard',
		'10.6' => 'Snow Leopard',
		'10.7' => 'Lion',
		'10.8' => 'Mountain Lion',
		'10.9' => 'Mavericks',
	}

	file { [ /var/db/.puppet_pkgdmg_installed_\$osnickname ]
		ensure 	=> absent,
		recurse => true,
		force 	=> yes,
		
	}

	package { [ macports ] :
		provider 	=> pkgdmg
		source 		=> 'https://distfiles.macports.org/MacPorts/MacPorts-current-\$osnickname.pkg'
		ensure 		=> present,
		subscribe 	=> File[ /var/db/.puppet_pkgdmg_installed_\$osnickname ],

	}

	schedule { [ 'everyday' ];
		period => daily,
		range  => '2-4',
	}

	exec { '/opt/local/bin/port selfupdate': 
		schedule 	=> 'everyday',
		subscribe 	=> Package[ 'macports' ],
	}

	file { [/opt/local/etc/macports/variants.conf] 
		source 		=> file://./puppet/macports/variants.conf,
		ensure 		=> present,
		mode 		=> 644,
		owner 		=> root,
		group 		=> admin,
		subscribe 	=> Package[ 'macports' ],
	}

}
";

	open my $filehandle, '>', $macports_manifest or die "$0: Cannot overwrite $macports_manifest : $!";

	printf $filehandle $writebuffer;
	close $filehandle;

}


sub chef_recipe
{

}


sub ansible_module 
{

}


sub cfengine 
{

}


sub homebrew
{

}


sub nix
{

}

sub cli
{

	my %portshash 		 = get_portpackagesandvariants( );
	my @listofpackages 	 = keys %portshash;

	@listofpackages 	= sort @listofpackages;

	my $writebuffer 	= '';
	foreach my $package ( @listofpackages ) {
		$writebuffer .= $package.' '.$portshash{ $package }. ' ';
	}

	my $installer_bin = $macports_bin ? $macports_bin : '';
	printf "$installer_bin install %s\n", $writebuffer;

}


sub dispatch
{
	my ( $automationthing , $action ) = @_;

	my $dispatch_table  = { 
			puppet 		=> \&puppet_template,
			chef   		=> \&chef_recipe,
			ansible 	=> \&ansible_module,
			cfengine 	=> \&cfegine,
			cli 		=> \&cli,
			_DEFAULT_ 	=> \&help
	};

	exists $dispatch_table->{ $action } or 
		die "$action is unknown. If this is a bug, report it.";

	if( $action ) {
		$dispatch_table->{ $action }->();
	}
}

sub help {

	print "this is the help\n";

}

sub main
{

	GetOptions( 'export-as:s' => \&dispatch, 'filename:s' => \&filename, 'help' => \&help );

	exit 0;

}

main( );