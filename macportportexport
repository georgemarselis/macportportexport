#!/opt/local/bin/perl -w


# macportportexport: reconstruct a macport command line, so you can reuse
#	your programs.
# 		Also, produces puppet templates, chef recepies and ansible solutions

# Copyright 2014 George Marselis <george@marsel.is>

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Data::Dumper;
use File::Copy;
use POSIX qw(strftime);
use Getopt::Long;

my $port_bin = '/opt/local/bin/port';

sub get_portpackagesandvariants
{

	my $action = 'installed';
	my $type    = 'active';
	my @args 	= ( $action, $type );

	open( my $porthandle, '-|', $port_bin, @args ) or
		die "Cannot run $port_bin: $!";

	return parse( <$porthandle> );

}


sub parse
{

	my @list 		= @_;
	my %portshash 	= ( );
	my $variants 	= '';
	
	foreach( @list ) {

		/The following/ and next;

		my $tempbuffer = $_; 	# read in, clean up.
		chomp $tempbuffer;
		$tempbuffer =~ s/^\s*//;
		$tempbuffer =~ s/ \(active\)//;
		$tempbuffer =~ s/@//g;

		my ( $program_name , $variants_in ) = split ' ', $tempbuffer;
		
		if( $variants_in =~ /\+\w+/ ) {

			( my $foo , $variants_in )	= split /\+/, $variants_in, 2;  # get the variants as string
			my @temparray				= split /\+/, $variants_in;     # resplit them 
			$variants 					= '+'.join( ' +', @temparray ); # re-join them, adding appropriate spaces		
		}

		$portshash{ $program_name } = $variants;
	}

	return %portshash;
}


###########
# dump the list of packages and variants as modules, ready to 
# 	puppet apply them
#
sub puppet_template
{
	my $root_dir		= 'puppet';

	my %portshash 		 = get_portpackagesandvariants( );
	my @listofpackages 	 = keys %portshash;
	my $stringofvariants = get_stringofvariants( %portshash );

	create_root_directory( $root_dir );
	write_root_manifest( $root_dir, @listofpackages );
	create_module_hierarchy( $root_dir, @listofpackages );
	write_module_manistests( $root_dir, @listofpackages );
	write_macports_manifest( $root_dir );
	write_variants_conffile( $root_dir, $stringofvariants );
	
	print "\nYour puppet files are ready. Please type\n\tsudo puppet apply --verbose ./$root_dir/manifests/site.pp --modulepath=puppet/modules\n\n".
			" to apply your puppet manifestos.\n";

}


sub get_stringofvariants 
{
	my %portshash 		= @_;
	my @packages 		= keys %portshash;
	my %variantshash  	= ( );
	my $stringofvariants = '';
	
	foreach my $package ( @packages ) {

		if( $portshash{ $package } =~ /\+/ ) {

			my @variants = split /\+/, $portshash{ $package };

			foreach my $variant ( @variants ) {
				chomp $variant;
				$variant =~ s/\s*$//;
				if( $variant ne '' and ! exists $variantshash{ $variant } ) {
					$variantshash{ $variant } = 1;
				}
			}
		}
	}

	foreach( keys %variantshash ) {
		if( $variantshash{ $_ } ne '' ) {
			$stringofvariants .= ' +'.$_ ;
		}
	}

	return $stringofvariants
}

sub create_root_directory
{
	my $root_dir = $_[0];

	if( ! -d $root_dir ) {
		mkdir $root_dir or
			die $0." cannot create root puppet dir $root_dir: $!";
	}
}

sub write_macports_manifest 
{

	my $root 			= $_[0];
	my $modules_dir 	= $root.'/modules';
	my $macports_module 			= $modules_dir.'/macports';
	my $macports_module_manifestdir = $macports_module.'/manifests';
	my $macports_manifest 			= $macports_module_manifestdir.'/init.pp';
	my $macports_module_filesdir	= $macports_module.'/files';
	my $writebuffer 	= '';


	( ! -d $macports_module 			) and mkdir $macports_module; 
	( ! -d $macports_module_manifestdir ) and mkdir $macports_module_manifestdir;
	( ! -d $macports_module_filesdir 	) and mkdir $macports_module_filesdir;



	$writebuffer  = "
class macports {


	\$osnickname = \$macosx_productversion_major ? {
		'10.5' => 'Leopard',
		'10.6' => 'Snow Leopard',
		'10.7' => 'Lion',
		'10.8' => 'Mountain Lion',
		'10.9' => 'Mavericks',
	}

	file { [ /var/db/.puppet_pkgdmg_installed_\$osnickname ]
		ensure 	=> absent,
		recurse => true,
		force 	=> yes,
		
	}

	package { [ macports ] :
		provider 	=> pkgdmg
		source 		=> 'https://distfiles.macports.org/MacPorts/MacPorts-current-\$osnickname.pkg'
		ensure 		=> present,
		subscribe   => File[ /var/db/.puppet_pkgdmg_installed_\$osnickname ],

	}

	schedule { [ 'everyday' ];
		period => daily,
		range  => '2-4',
	}

	exec { '/opt/local/bin/port selfupdate': 
		schedule 	=> 'everyday',
		subscribe 	=> Package[ 'macports' ],
	}

	file { [/opt/local/etc/macports/variants.conf] 
		source 		=> file://./puppet/macports/variants.conf,
		ensure 		=> present,
		mode 		=> 644,
		owner 		=> root,
		group 		=> admin,
		subscribe 	=> Package[ 'macports' ],
	}

}
";

	open my $filehandle, '>', $macports_manifest or die "$0: Cannot overwrite $macports_manifest : $!";

	printf $filehandle $writebuffer;
	close $filehandle;

}


sub write_root_manifest 
{ 

	my ( $root_dir, @listofpackages ) = @_;
	my $writebuffer 	= '';

	my $datestring = strftime "%Y-%m-%d_%T", localtime;
	$writebuffer = "
########################################################################
#
# Autogenerated by $0 on $datestring
#

";
	@listofpackages = sort @listofpackages;
	foreach my $package ( @listofpackages )	{
		$package =~ s/\./-/g;
		$writebuffer .= sprintf( "include $package\n" );
	}

	open my $filehandle, '>', $root_dir.'/start.pp';
	printf $filehandle $writebuffer;

	close $filehandle;

}


sub create_module_hierarchy 
{
	my ( $root_dir, @listofpackages ) 	= @_;
	my $modules_dir 					= $root_dir.'/modules';
	
	( ! -d $modules_dir ) and mkdir $modules_dir 	or die "$0: could not make $modules_dir: $!";

	foreach( @listofpackages ) {
			
		my $puppetmodule_dir 		= $modules_dir.'/'.$_;
		my $puppetmanifest_dir 		= $puppetmodule_dir.'/manifests';
	
		if( ! -d $puppetmodule_dir ) {
			mkdir $puppetmodule_dir or 
				die "$0: could not create directory $puppetmodule_dir : $!";
		}

		if( ! -d $puppetmanifest_dir ) {
			mkdir $puppetmanifest_dir or 
				die "$0: could not create directory $puppetmanifest_dir : $!";
		}
	}
}


sub write_module_manistests
{
	my ( $root_dir, @listofpackages ) 	= @_;
	my $modules_dir 					= $root_dir.'/modules';

	foreach my $package ( @listofpackages ) {
		
		my $puppet_module_dir 			= $modules_dir.'/'.$package;
		my $puppet_module_manifest_dir 	= $puppet_module_dir.'/manifests';
		my $puppet_module_manifest_file = $puppet_module_manifest_dir.'/init.pp';

		( ! -d $puppet_module_manifest_dir ) and die ": $puppet_module_manifest_dir does not exist";
		open my $filehandle, '>', $puppet_module_manifest_file or die ": could not open $puppet_module_manifest_file : $!";

		$package =~ s/\./-/g;
		my $writebuffer  = "
class $package {

	package { [ \"$package\" ] :
		provider 	=> 'macports',
		ensure 		=> present,

	}
}
";
		printf $filehandle $writebuffer or die "$0: cannot print to file $puppet_module_manifest_file : $!";
		close $filehandle;
	}

}

sub write_variants_conffile 
{

	my ( $root_dir, $stringofvariants )	= @_;
	my $macportsvariantsconf_file 		= '/opt/local/etc/macports/variants.conf';
	my $macports_module_files_dir	 	= $root_dir.'/modules/macports/files';
	my $macports_module_variants_file   = $macports_module_files_dir.'/variants.conf';
	my $writebuffer 					= '';


	if( -e $macportsvariantsconf_file ) {

		# write warning to user that file exists and should not overwrite it,
		# but append to it.
		$writebuffer = "#
# PLEASE READ: 
#   Your / opt/local/etc/macports/variants.conf is not empty.
#
# 	You should take a look at the contents of the file and consider if you need to 
#	append to the file or overwrite it.
#
";
	}

	$stringofvariants =~ s/^\s*//;

	$writebuffer .= sprintf( "%s\n", $stringofvariants );

	( ! -d $macports_module_files_dir ) and die "$macports_module_files_dir does not exist";
	open( my $filehandle, ">", $macports_module_variants_file ) or 
		die $macports_module_variants_file.' could not be written; exiting';
	printf $filehandle $writebuffer;
	close $filehandle;
}


sub chef_recipe
{

}

sub ansible_module 
{

}

sub cfengine 
{

}

sub dispatch
{
	my ( $automationthing , $action ) = @_;

	my $dispatch_table  = { 
			puppet 		=> \&puppet_template,
			chef   		=> \&chef_recipe,
			ansible 	=> \&ansible_module,
			cfengine 	=> \&cfegine,
			cli 		=> \&get_portpackagesandvariants,
			_DEFAULT_ 	=> \&help
	};

	exists $dispatch_table->{ $action } or 
		die "$action is unknown. If this is a bug, report it.";

	if( $action ) {
		$dispatch_table->{ $action }->();
	}

	exit 0;
}

sub help {

	print "this is the help\n";

	exit 0;
}

sub main
{

	GetOptions( 'export:s' => \&dispatch, 'filename:s' => \&filename, 'help' => \&help );

	exit 0;

}

main( );