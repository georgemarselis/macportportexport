#!/opt/local/bin/perl -w


# macportportexport: reconstruct a macport command line, so you can reuse
#	your programs.
# 		Also, produces puppet templates, chef recepies and ansible solutions

# Copyright 2014 George Marselis <george@marsel.is>

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


use Data::Dumper;
use File::Copy;
use POSIX qw(strftime);
use Getopt::Long;

use strict;
use warnings;

my $portbin = '/opt/local/bin/port';

sub port_readports
{

	my $action = 'installed';
	my $type    = 'active';
	my @args 	= ( $action, $type );

	open( my $porthandle, '-|', $portbin, @args ) or
		die "Cannot run $portbin: $!";

	return parse( <$porthandle> );

}

sub parse
{

	my @list = @_;
	
	my @commandline;
	foreach( @list ) {

		/The following/ and next;

		my $tempbuffer = $_; 	# read in, clean up.
		chomp $tempbuffer;
		$tempbuffer =~ s/^\s*//;
		$tempbuffer =~ s/ \(active\)//;
		$tempbuffer =~ s/@//g;

		my $programname 	= '';
		my $versionvariants = '';

		( $programname , $versionvariants ) = split ' ', $tempbuffer;
		$tempbuffer = '';
		
		if( $versionvariants =~ /\+\w+/ ) {

			( my $foo , $versionvariants ) = split '\+', $versionvariants, 2;
			my @options = split '\+', $versionvariants;
			#print Dumper @options;
			$tempbuffer = ' +'.join( ' +', @options );
		}

		push @commandline, $programname.$tempbuffer;

	}

	return @commandline;
}

sub ansible_solution
{

}

sub writevariantsconffile 
{

	my @listofvariants 				= @_;
	my $macportsvariantsconf_file 	= '/opt/local/etc/macports/variants.conf';
	my $puppetvariantsconf_file 	= './variants.conf';
	my $writebuffer 				= '';


	if( -e $macportsvariantsconf_file ) {

		# write warning to user that file exists and should not overwrite it,
		# but append to it.
		$writebuffer = "
#
# PLEASE READ: 
#   Your /opt/local/etc/macports/variants.conf is not empty.
#
# 	You should take a look at the contents of the file and consider if you need to 
#	append to the file or overwrite it.
#
";
}
	# write the variants in a local file
	if( -f $puppetvariantsconf_file ) {
		warn $puppetvariantsconf_file.' exists; Will be backed up to '.$puppetvariantsconf_file.'.bak';
		move( $puppetvariantsconf_file, $puppetvariantsconf_file.'.bak' ) or 
			die $puppetvariantsconf_file.'.bak could not be written; exiting';
			

	}

	open( my $filehandle, ">", $puppetvariantsconf_file ) or 
		die $puppetvariantsconf_file.' could not be written; exiting';

	print $filehandle $writebuffer;
	print $filehandle join( ' ', @listofvariants );

	close $filehandle;

	print 'Variants file '.$puppetvariantsconf_file.' written';


}

# this should write a puppet manifest or a facter extension
sub write_detectos_manifest {

	my $osversion 		= exec( "facter macosx_productversion_major" );
	my %osnicknamelist  = 	{ 	
								'10.5' => 'Leopard',
								'10.6' => 'Snow Leopard',
								'10.7' => 'Lion',
								'10.8' => 'Mountain Lion',
								'10.9' => 'Mavericks'
							};

	return $osnicknamelist{ $osversion } ;
}


sub writemacports_manifest 
{

	my @listofvariants = @_;

	my $root 			= './puppet';
	my $modules_dir 	= $root.'/modules';
	my $puppetvariantsconf_file = './variants.conf';

	my $writebuffer 	= '';
	my $osnickname 		= write_detectos_manifest( );


	
	my $macports_module 			= $modules_dir.'/macports';
	my $macports_module_manifestdir = $macports_module.'/manifests';
	my $macports_manifest 			= $macports_module_manifestdir.'/init.pp';
	my $macports_module_filesdir	= $macports_module.'/files';


	( ! -d $macports_module 			) and mkdir $macports_module; 
	( ! -d $macports_module_manifestdir ) and mkdir $macports_module_manifestdir;
	( ! -d $macports_module_filesdir 	) and mkdir $macports_module_filesdir;

	writevariantsconffile( @listofvariants );
	move( $puppetvariantsconf_file, $macports_module_filesdir );

	$writebuffer  = "
class macports {


	$osnickname = \$macosx_productversion_major ? {
		'10.5' => 'Leopard',
		'10.6' => 'Snow Leopard',
		'10.7' => 'Lion',
		'10.8' => 'Mountain Lion',
		'10.9' => 'Mavericks',
	}

	file { [ /var/db/.puppet_pkgdmg_installed_$osnickname ]
		ensure 	=> absent,
		recurse => true,
		force 	=> yes,
		
	}
]
	package { [ macports ] :
		provider 	=> pkgdmg
		source 		=> 'https://distfiles.macports.org/MacPorts/MacPorts-current-$osnickname.pkg'
		ensure 		=> present,
		subscribe   => File[ /var/db/.puppet_pkgdmg_installed_$osnickname ],

	}

	schedule { [ 'everyday' ];
		period => daily,
		range  => '2-4',
	}

	exec { '/opt/local/bin/port selfupdate': 
		schedule 	=> 'everyday',
		subscribe 	=> Package[ 'macports' ],
	}

	file { [/opt/local/etc/macports/variants.conf] 
		source 		=> file://./modules/macports/variants.conf,
		ensure 		=> present,
		mode 		=> 644,
		owner 		=> root,
		group 		=> admin,
		subscribe 	=> Package[ 'macports' ],
	}

}
";

	open my $filehandle, '>', $macports_manifest or die "$0: Cannot overwrite $macports_manifest : $!";
	print $filehandle $writebuffer;
	close $filehandle;

}

###########
# dump the list of packages and variants as modules, ready to 
# 	puppet apply them
#
sub puppet_template
{
	my @listofpackages 	= ( );
	my @listofvariants 	= ( );
	my $root_dir		= './puppet';
	my $modules_dir 	= $root_dir.'/modules';
	my $defaults_dir 	= $modules_dir.'/defaults';
	my $writebuffer 	= '';

	( ! -d $root_dir 	) and mkdir $root_dir 		or die "$0: could not make $root_dir: $!";
	( ! -d $modules_dir ) and mkdir $modules_dir 	or die "$0: could not make $modules_dir: $!";

	foreach( @listofpackages ) {
		
		my $puppetmodule_dir 		= $modules_dir.'/'.$_;
		my $puppetmanifest_dir 		= $puppetmodule_dir.'/manifests';
		my $puppetmanifest_file  	= $puppetmanifest_dir.'/init.pp';

		if( ! -d $puppetmanifest_dir ) {
			mkdir $puppetmanifest_dir or 
				die "$0: could not create directory $puppetmanifest_dir : $!";
		}

		open my $filehandle, '>', $puppetmanifest_file or die "$0: could not open $puppetmanifest_file : $!";

		$writebuffer  = "
class $_ {

	package { [ $_ ] :
		provider 	=> 'macports',
		ensure 		=> present,

	}

}
";
		print $filehandle $writebuffer or die "$0: cannot print to file $puppetmanifest_file : $!";
		close $filehandle;
	}

	#my $datestring = strftime "%Y-%m-%d_%T", localtime;
	$writebuffer = "
########################################################################
#
# Autogenerated by $0 on FIXME
#
";#, $datestring );
	
	open my $filehandle, '>', $root_dir.'/macports.pp';
	print $filehandle $writebuffer;

	foreach( @listofpackages )	{
		print $filehandle "include $_";
	}
	close $filehandle;

	writemacports_manifest( );


	print "\nYour puppet files are ready. Please type\n\tsudo puppet apply ./$root_dir/macports.pp\n\n to apply your puppet manifestos.\n";

}

sub chef_recepie
{

}

sub exportto
{
	my ( $automationthing , $automationvalue ) = @_;

	\$automationvalue;
}

sub main
{

	my $exportto = '';
	my $filename = '';

	GetOptions( 'exportto:s' => \$exportto, 'filename:s' => \$filename );

	my @output = port_readports( );
	printf "port install %s\n", join( ' ', @output );
}

main( );